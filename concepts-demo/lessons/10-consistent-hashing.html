<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consistent Hashing | System Design Mastery</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles/main.css">
    <style>
        .ring-container {
            position: relative;
            width: 350px;
            height: 350px;
            margin: 0 auto;
        }

        .ring-circle {
            position: absolute;
            inset: 10px;
            border: 3px dashed var(--border-light);
            border-radius: 50%;
        }

        .ring-node {
            position: absolute;
            width: 50px;
            height: 50px;
            background: var(--accent-gradient);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            font-weight: 600;
            color: white;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.2s;
            z-index: 2;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
        }

        .ring-node:hover {
            transform: translate(-50%, -50%) scale(1.15);
        }

        .ring-node.virtual {
            background: linear-gradient(135deg, #334155, #475569);
            box-shadow: none;
            width: 35px;
            height: 35px;
            font-size: 0.7rem;
        }

        .ring-key {
            position: absolute;
            width: 30px;
            height: 30px;
            background: var(--warning);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 600;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        .assignment-line {
            position: absolute;
            height: 2px;
            background: var(--warning);
            transform-origin: left center;
            pointer-events: none;
            opacity: 0.5;
            z-index: 0;
        }

        .distribution-bar {
            display: flex;
            height: 30px;
            border-radius: var(--radius-md);
            overflow: hidden;
            margin: 1rem 0;
        }

        .dist-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            transition: width 0.3s;
        }
    </style>
</head>

<body>
    <div class="bg-pattern"></div>
    <div class="bg-grid"></div>
    <nav class="nav">
        <div class="container nav-content"><a href="../index.html" class="nav-logo">System Design Mastery</a></div>
    </nav>

    <div class="lesson-container">
        <div class="container">
            <header class="lesson-header">
                <div class="lesson-meta"><span class="lesson-number">üíç</span><span class="tag">Module 10</span></div>
                <h1>Consistent Hashing</h1>
                <p style="color: var(--text-secondary); max-width: 700px;">Distribute data across a cluster of nodes
                    such that adding or removing a node only requires redistributing a minimal amount of keys.</p>
            </header>

            <div class="lesson-content">
                <section class="lesson-section">
                    <h3>The Problem with Modulo Hashing</h3>
                    <p>With simple <code>hash(key) % N</code>, adding one server means almost ALL keys need to move.</p>
                    <div class="demo-container" style="margin-top: 1rem;">
                        <div class="demo-body">
                            <div class="code-block">
                                <span class="comment">// Before: 3 servers</span>
                                key "user:123" ‚Üí hash % 3 = <span class="string">Server 1</span>

                                <span class="comment">// After: 4 servers (added one!)</span>
                                key "user:123" ‚Üí hash % 4 = <span class="string">Server 2</span> <span class="comment">‚Üê
                                    Key moved!</span>

                                <span class="comment">// ~75% of keys need to move when going from 3‚Üí4 servers</span>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="lesson-section">
                    <h3>Interactive Hash Ring</h3>
                    <p>Keys are assigned to the first node encountered clockwise. Add/remove nodes to see minimal
                        redistribution.</p>
                    <div class="demo-container">
                        <div class="demo-header"><span class="demo-dot red"></span><span
                                class="demo-dot yellow"></span><span class="demo-dot green"></span><span
                                class="demo-title">Consistent Hash Ring</span></div>
                        <div class="demo-body">
                            <div class="controls">
                                <button class="btn btn-primary" onclick="addNode()">Add Node</button>
                                <button class="btn btn-secondary" onclick="removeNode()">Remove Node</button>
                                <button class="btn btn-secondary" onclick="addKeys(3)">Add 3 Keys</button>
                                <button class="btn btn-secondary" onclick="toggleVirtual()">Toggle Virtual
                                    Nodes</button>
                                <button class="btn btn-secondary" onclick="traceRequest()">Trace Request</button>
                                <button class="btn btn-secondary" onclick="resetRing()">Reset</button>
                            </div>
                            <div class="controls" style="margin-top:0.5rem; justify-content:center;">
                                <label
                                    style="display:flex; align-items:center; gap:0.5rem; cursor:pointer; font-weight:500;">
                                    <input type="checkbox" id="boundedLoadCheck" onchange="toggleBoundedLoad()">
                                    Enable Bounded Load (Max = Avg * 1.3)
                                </label>
                            </div>
                            <div class="ring-container" id="ringContainer">
                                <div class="ring-circle"></div>
                            </div>
                            <div style="font-weight: 600; margin-top: 1rem;">Key Distribution</div>
                            <div class="distribution-bar" id="distBar"></div>
                            <div id="ringInfo" style="font-size: 0.85rem; color: var(--text-secondary);"></div>
                        </div>
                    </div>
                </section>

                <section class="lesson-section">
                    <h3>Virtual Nodes</h3>
                    <p>To improve load distribution, each physical node is mapped to multiple positions on the ring.</p>
                    <div class="info-box tip">
                        <div class="info-box-title">Why Virtual Nodes?</div>
                        <p>With only physical nodes, distribution can be uneven. Virtual nodes (100-200 per physical)
                            smooth out the distribution and handle heterogeneous server capacities.</p>
                    </div>
                </section>

                <section class="lesson-section">
                    <h3>Key Lookup: O(log N)</h3>
                    <p>Finding which node owns a key is done with a binary search over sorted node positions.</p>
                    <div class="code-block">
                        <span class="keyword">function</span> <span class="function">findNode</span>(key) {
                        <span class="keyword">const</span> keyHash = hash(key);
                        <span class="comment">// Binary search for first node >= keyHash</span>
                        <span class="keyword">const</span> idx = sortedNodes.<span
                            class="function">binarySearch</span>(keyHash);
                        <span class="keyword">return</span> sortedNodes[idx % sortedNodes.length];
                        }
                    </div>
                </section>

                <!-- Bounded Load -->
                <section class="lesson-section">
                    <h3>Bounded Load Consistent Hashing</h3>
                    <p>Problem: Even with virtual nodes, some servers can get overloaded. Bounded load sets a cap.</p>
                    <div class="formula-box"
                        style="background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: var(--radius-lg); padding: 1.5rem; text-align: center; margin: 1rem 0;">
                        <div style="font-family: var(--font-mono); font-size: 1.2rem; color: var(--accent-primary);">
                            max_load = ceil(total_load / num_servers √ó (1 + Œµ))
                        </div>
                        <p style="font-size: 0.85rem; color: var(--text-muted); margin-top: 0.5rem;">
                            Œµ = load balancing parameter (e.g., 0.25 = 25% extra capacity)
                        </p>
                    </div>
                    <div class="info-box tip">
                        <div class="info-box-title">üí° How It Works</div>
                        <p>If a server's load exceeds the bound, skip it and assign the key to the next server on the
                            ring. Ensures no server handles more than (1+Œµ) times the average load.</p>
                    </div>
                </section>

                <!-- Quiz -->
                <section class="lesson-section">
                    <h3>Check Your Understanding</h3>
                    <div class="quiz-container">
                        <p class="quiz-question">
                            You're migrating from 10 to 11 cache servers. With modulo hashing (hash % N), how many keys
                            move?
                        </p>
                        <div class="quiz-options" id="hashQuizOptions">
                            <div class="quiz-option" onclick="checkHashAnswer(this, false)">~10% ‚Äî only new server's
                                share</div>
                            <div class="quiz-option" onclick="checkHashAnswer(this, true)">~90% ‚Äî almost everything
                                rehashes</div>
                            <div class="quiz-option" onclick="checkHashAnswer(this, false)">~50% ‚Äî half of keys move
                            </div>
                            <div class="quiz-option" onclick="checkHashAnswer(this, false)">0% ‚Äî keys stay where they
                                are</div>
                        </div>
                        <div id="hashQuizFeedback" style="margin-top: 1rem; display: none;"></div>
                    </div>
                </section>

                <div class="lesson-nav">
                    <a href="09-cap-theorem.html" class="nav-btn">‚Üê CAP Theorem</a>
                    <a href="11-realtime.html" class="nav-btn">Real-time Communication ‚Üí</a>
                </div>
            </div>
        </div>
    </div>

    <div id="toast"
        style="position: fixed; bottom: 20px; right: 20px; background: var(--bg-tertiary); padding: 10px 20px; border-radius: 8px; border: 1px solid var(--border-light); transform: translateY(100px); transition: transform 0.3s; z-index: 1000;">
    </div>

    <script>
        let nodes = [], keys = [], nodeId = 0, keyId = 0, useVirtual = false;
        let boundedLoad = false;
        const cx = 175, cy = 175, r = 140;
        const colors = ['#6366f1', '#8b5cf6', '#ec4899', '#10b981', '#f59e0b', '#3b82f6'];

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.style.transform = 'translateY(0)';
            setTimeout(() => t.style.transform = 'translateY(100px)', 3000);
        }

        function toggleBoundedLoad() {
            boundedLoad = document.getElementById('boundedLoadCheck').checked;
            renderRing();
        }

        function posOnRing(hash, offset = 0) {
            const angle = (hash / 360) * 2 * Math.PI - Math.PI / 2;
            return { x: cx + (r + offset) * Math.cos(angle), y: cy + (r + offset) * Math.sin(angle) };
        }

        function addNode() {
            if (nodes.length >= 6) return;
            const id = ++nodeId;
            const baseHash = (id * 60) % 360;
            const color = colors[(id - 1) % colors.length];
            nodes.push({ id, hash: baseHash, color, virtual: useVirtual ? [baseHash, (baseHash + 120) % 360, (baseHash + 240) % 360] : [baseHash] });
            renderRing();
        }

        function removeNode() {
            if (nodes.length === 0) return;
            nodes.pop();
            renderRing();
        }

        function addKeys(count) {
            for (let i = 0; i < count; i++) keys.push({ id: ++keyId, hash: Math.floor(Math.random() * 360) });
            renderRing();
        }

        function toggleVirtual() {
            useVirtual = !useVirtual;
            nodes.forEach(n => n.virtual = useVirtual ? [n.hash, (n.hash + 120) % 360, (n.hash + 240) % 360] : [n.hash]);
            renderRing();
        }

        function resetRing() { nodes = []; keys = []; nodeId = keyId = 0; renderRing(); }

        function findOwner(keyHash, currentCounts = {}) {
            if (nodes.length === 0) return null;

            // GetAllPositions
            const allPositions = nodes.flatMap(n => n.virtual.map(v => ({ node: n, hash: v }))).sort((a, b) => a.hash - b.hash);

            // Find primary owner index
            let idx = allPositions.findIndex(p => p.hash >= keyHash);
            if (idx === -1) idx = 0;

            if (!boundedLoad) return allPositions[idx].node;

            // Bounded Load Logic
            const avg = keys.length / nodes.length;
            const limit = Math.ceil(avg * 1.3);
            if (limit < 1) return allPositions[idx].node; // Too few keys to bound

            // Linear probe for first non-full node
            const startIdx = idx;
            for (let i = 0; i < allPositions.length; i++) {
                const currIdx = (startIdx + i) % allPositions.length;
                const candidate = allPositions[currIdx].node;
                const currentLoad = currentCounts[candidate.id] || 0;

                if (currentLoad < limit) {
                    return candidate;
                }
            }
            // Fallback (should shouldn't happen if capacity exists)
            return allPositions[idx].node;
        }

        function traceRequest() {
            if (keys.length === 0 || nodes.length === 0) { showToast("Add keys/nodes to trace"); return; }
            const key = keys[keys.length - 1]; // Trace last key

            // Remove existing traces
            document.querySelectorAll('.trace-path').forEach(e => e.remove());

            const container = document.getElementById('ringContainer');
            const owner = findOwner(key.hash, getCounts()); // Need current counts for accurate trace if bounded

            // Visually find the "closest" virtual node clockwise to draw the arc
            // This is just for visual "search" effect
            const startAngle = (key.hash / 360) * 2 * Math.PI - Math.PI / 2;

            // Create a simpler visual indicator: a scanning arc
            const trace = document.createElement('div');
            trace.className = 'trace-path';
            trace.style.position = 'absolute';
            trace.style.inset = '20px'; // Inside ring
            trace.style.borderRadius = '50%';
            trace.style.border = '2px solid var(--accent-primary)';
            trace.style.opacity = '0';
            trace.style.transition = 'all 1s';
            trace.style.clipPath = 'polygon(50% 50%, 50% 0%, 100% 0, 100% 100%, 0 100%, 0 0, 50% 0)'; // Hacky full circle

            // Better: Just animate a dot moving
            const dot = document.createElement('div');
            dot.className = 'trace-dot';
            dot.style.position = 'absolute';
            dot.style.width = '10px';
            dot.style.height = '10px';
            dot.style.background = 'white';
            dot.style.borderRadius = '50%';
            dot.style.zIndex = '10';
            dot.style.boxShadow = '0 0 10px var(--accent-primary)';
            dot.style.left = (cx + r * Math.cos(startAngle)) + 'px';
            dot.style.top = (cy + r * Math.sin(startAngle)) + 'px';
            dot.style.transition = 'all 1.5s cubic-bezier(0.25, 1, 0.5, 1)';

            container.appendChild(dot);

            // Find target pos (approximate for visual)
            // We know the owner, but which virtual node caught it?
            // Re-run simple search to find the "hit" virtual node
            const allPositions = nodes.flatMap(n => n.virtual.map(v => ({ node: n, hash: v }))).sort((a, b) => a.hash - b.hash);
            // ... (Simple trace logic: just move to element of owner)
            // For simplicity, just move to the physical node's first position or the owner's icon

            // Let's actually find the specific virtual node hash that 'caught' it in the logic
            // Note: Bounded load might have skipped the first one.
            // This visual trace is approximate.

            // Final position of the owner node's main element
            // We'll just animate to the center for "Found!" effect
            // Actually, let's animate to the owner node's physical position (first virtual node usually)
            const targetHash = owner.virtual[0];
            const targetAngle = (targetHash / 360) * 2 * Math.PI - Math.PI / 2;

            setTimeout(() => {
                dot.style.left = (cx + r * Math.cos(targetAngle)) + 'px';
                dot.style.top = (cy + r * Math.sin(targetAngle)) + 'px';
                dot.style.transform = 'scale(2)';
                dot.style.background = owner.color;
            }, 100);

            setTimeout(() => {
                dot.remove();
                showToast(`request routed to Node ${owner.id}`);
            }, 1600);
        }

        function getCounts() {
            const counts = {};
            nodes.forEach(n => counts[n.id] = 0);
            // Simulate load for all keys except the last one (which we are tracing)
            for (let i = 0; i < keys.length - 1; i++) {
                const k = keys[i];
                const owner = findOwner(k.hash, counts);
                if (owner) counts[owner.id]++;
            }
            return counts;
        }

        function renderRing() {
            const container = document.getElementById('ringContainer');
            container.querySelectorAll('.ring-node, .ring-key, .assignment-line').forEach(el => el.remove());

            nodes.forEach(n => {
                n.virtual.forEach((hash, i) => {
                    const pos = posOnRing(hash);
                    const el = document.createElement('div');
                    el.className = 'ring-node' + (i > 0 ? ' virtual' : '');
                    el.textContent = i > 0 ? `${n.id}'` : `N${n.id}`;
                    el.style.left = pos.x + 'px'; el.style.top = pos.y + 'px';
                    el.style.background = i > 0 ? '' : n.color;
                    container.appendChild(el);
                });
            });

            const counts = {};
            nodes.forEach(n => counts[n.id] = 0);

            // Correct assignment loop for Bounded Load compliance
            keys.forEach(k => {
                const owner = findOwner(k.hash, counts); // Pass current counts
                if (owner) {
                    counts[owner.id]++;

                    // Render Key
                    const pos = posOnRing(k.hash, -35);
                    const el = document.createElement('div');
                    el.className = 'ring-key';
                    el.textContent = `K${k.id}`;
                    el.style.left = pos.x + 'px'; el.style.top = pos.y + 'px';
                    container.appendChild(el);

                    // Connection line
                    // Optional: too messy if many keys
                }
            });

            updateDistribution(counts);
            document.getElementById('ringInfo').textContent = `${nodes.length} nodes, ${keys.length} keys` + (useVirtual ? ` (${nodes.length * 3} virtual nodes)` : '');
        }

        function updateDistribution(counts) {
            const bar = document.getElementById('distBar');
            if (nodes.length === 0 || keys.length === 0) { bar.innerHTML = '<div style="flex:1; background: var(--bg-tertiary); display:flex; align-items:center; justify-content:center; color: var(--text-muted);">No data</div>'; return; }
            bar.innerHTML = nodes.map(n => {
                const pct = (counts[n.id] / keys.length) * 100;
                return `<div class="dist-segment" style="width: ${pct}%; background: ${n.color};">${pct > 10 ? Math.round(pct) + '%' : ''}</div>`;
            }).join('');
        }

        renderRing();

        // Quiz
        function checkHashAnswer(el, correct) {
            const options = document.querySelectorAll('#hashQuizOptions .quiz-option');
            options.forEach(opt => { opt.style.pointerEvents = 'none'; opt.classList.remove('correct', 'incorrect'); });
            el.classList.add(correct ? 'correct' : 'incorrect');
            if (!correct) options[1].classList.add('correct');
            const feedback = document.getElementById('hashQuizFeedback');
            feedback.style.display = 'block';
            feedback.innerHTML = correct
                ? '<div class="info-box tip"><div class="info-box-title">‚úÖ Correct!</div><p>With modulo hashing, changing N from 10 to 11 means hash(key) % 10 ‚â† hash(key) % 11 for most keys. Consistent hashing solves this ‚Äî only ~10% of keys move (the new server\'s share).</p></div>'
                : '<div class="info-box warning"><div class="info-box-title">‚ùå Not quite</div><p>Modulo hashing has a massive rehashing problem. Going from 10‚Üí11 servers means almost all keys get a new server assignment. That\'s why we use consistent hashing!</p></div>';
        }
    </script>
</body>

</html>